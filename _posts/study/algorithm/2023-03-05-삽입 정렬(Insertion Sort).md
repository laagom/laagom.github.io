---
layout: post
title:  "[Algorithm] 삽입 정렬 (Insertion Sort)"
subtitle:   "삽입 정렬 (Insertion Sort)"
date: 2023-03-05
categories: study
tags: algorithm
comments: true
related_posts:
image: /assets/img/lagom.png
---

# 삽입 정렬(Insertion Sort)
정렬 알고리즘 중에서 가장 직관적이고 쉽게 구현이 가능한 선택 정렬(Selection Sort)에 대해 알아보려고 한다.

<br>

### <span style='color:hsl(350, 100%, 66%);'>개념</span>
[`선택정렬`](https://laagom.github.io/study/2023/02/02/%EC%84%A0%ED%83%9D-%EC%A0%95%EB%A0%AC(Selection-Sort).html),[`거품정렬`](https://laagom.github.io/study/2023/01/25/%EA%B1%B0%ED%92%88-%EC%A0%95%EB%A0%AC(Bubble-Sort).html)과 더불어 시간복잡도를 O(N^2)가지고 있는 삽입정렬에 대해 알아보려고 한다. 시간 복잡도가 O(N^2)을 가지고 있다고 하지만 `선택정렬`, `삽입정렬`보다 좀 더 효율적인 알고리즘이다. 최선의 경우에는 O(N)이라는 엄청나게 빠른 효율성을 가지고 있어 `다른 정렬 알고리즘의 일부로 사용될 만큼 좋은 정렬 알고리즘`이다.

삽입 정렬은 정렬 범위를 1칸씩 확장해나가면서 새롭게 정렬 범위에 들어온 값을 기존 값들과 비교하여 알맞은 자리에 넣어주는 알고리즘이다. 좀더 자세하게 말하면 2번째 원소부터 시작하여 그 앞(왼쪽)의 원소들과 비교하여 삽입할 위치를 지정한 후 원소를 뒤로 옮기고 지정된 자리에 자료를 삽입하여 정렬하는 구조를 가지고 있다.

이제 하나의 배열을 가지고 위에서 설명한 `삽입 정렬`이 어떻게 진행되는지 알아보자.

예를 들어, 다음과 같이 1부터 5까지 총 5개의 숫자가 들어있는 배열에 있다고 가정해보자.
```text
[2, 1, 5, 4, 3]
```
맨 처음에는 첫번째 2개의 값만 정렬 범위에 포함을 시키고, 앞에 있는 값 `2`가 뒤에 있는 값 `1`보다 크기 대문에 서로의 자리를 바꿔준다.
```text
[2, 1] : 2 > 1 => switch

[1, 2] 
```
그 다음에는 기존의 정렬 범위에 한칸 확장하여 세번째 값을 추가하고, 기존 정렬 범위에서 가장 큰 값인 `2`와 새롭게 추가된 `5`를 비교하면 자리를 바꿀 필요가 없다는 것을 알 수 있다. 기존에 정렬 범위에 있던 두 개의 값은 이 전 패스에서 이미 정렬이 되어 있기 때문에 굳이 `1`, `5`를 비교할 필요가 없다.
```text
[1, 2, 5] : 2 < 5 => OK

[1, 2, 5]
```
다음 패스에서는 정렬 범위를 한 칸 더 확장하여 4번째 값을 추가시키고, 기존 정렬 범위에서 가장 큰 값인 `5`와 새롭게 추가된 `4`를 비교하면, 앞의 값이 뒤에 있는 값보다 크기 때문에 서로의 자리를 바꿔준다. 이제 기존 정렬 범위에서 두번째로 큰 값인 `2`와 방금 자리를 교체 당한 `4`를 비교해보면 더 이상 자리를 바꿀 필요가 없다는 것을 알 수 있다.
```text
[1, 2, 5, 4] : 5 > 4 => switch

[1, 2, 4, 5] : 2 < 4 => OK

[1, 2, 4, 5]
```
마지막 패스에서는 정렬 범위를 전체로 확장하여 마지막까지 포함시키고, 지금까지 했던 방식과 동일하게 새로 추가된 값과 기존에 있던 값들을 비교하며 2번의 자리 교체가 필요한 것을 알 수 있다.
```text
[1, 2, 4, 5, 3] : 5 > 3 => switch

[1, 2, 4, 3, 5] : 4 > 3 => switch

[1, 2, 3, 4, 5] : 2 < 3 => OK
```

<br>

### <span style='color:hsl(350, 100%, 66%);'>GIF로 이해하는 Insertion Sort</span>

<img src="/assets/resources/insertion-sort-001.gif">

<br>

### <span style='color:hsl(350, 100%, 66%);'>특징</span>
1. 선택/거품 정렬은 패스가 거듭될 수록 탐색 범위가 줄어드는 반면 삽입 정렬은 오히려 점점 정렬 범위가 넓어진다.
2. 큰 그림에서 보았을 때 바깥 쪽 루프는 순방향, 안 쪽 루프는 역방향으로 진행하고 있다.

<br>

### <span style='color:hsl(350, 100%, 66%);'>복잡도</span>
1. 삽입 정렬은 별도의 추가 공간을 사용하지 않고 주어진 배열이 차지하고 있는 공간 내에서 값들의 위치만 바꾸기 때문에 O(1)의 공간 복잡도를 가진다.
2. 시간 복잡도는 우선 루프문을 통해 정렬 범위를 2개로 시작해서 전체로 확장해야 하기 때문에 기본적으로 O(N)의 시간 소모를 하며, 각 패스에서 정렬 범위에 새롭게 추가된 값과 기존 값들의 대소 비교 및 자리 교대를 위해 O(N)의 시간이 필요하다. 따라서 삽입 정렬은 총(N^2)의 시간 복잡도를 자지는 정렬 알고리즘이다.
3. 최적화를 통해 부분적으로 정렬된 배열에 대해 성능을 대폭 개선할 수 있으며, 특히 완전히 정렬되어 있는 배열이 들어오는 경우 O(N)까지도 시간 복잡도를 향상시킬 수 있다.

<br>

### <span style='color:hsl(350, 100%, 66%);'>Python 코드</span>
두 개의 반복문이 필요하며, 내부 반복문에서는 정렬 범위에 새롭게 추가된 값과 기존 값들을 뒤에서 부터 비교해가며 앞의 값이 뒤의 값보다 큰 경우 바꿔주며, 외부 반복문을 정렬 범위 2~N까지 확대해 나간다.
```python
array = [3, 2, 1, 6, 5, 4, 9, 8, 7]

for end in range(1, len(array)):
    for i in range(end, 0, -1):
        if array[i-1] > array[i]:
            array[i-1], array[i] = array[i], array[i-2]

print(array)

'''
[1, 2, 3, 4, 5, 6, 7, 8, 9]
'''
```

<br>

### <span style='color:hsl(350, 100%, 66%);'>최적화</span>
기존에 있던 값들은 이전 패스에서 모두 정렬되었다는 점을 활용하면 `불필요한 비교 작업을 제거`할 수 있다. 예를 들면, 아래와 같이 기존 정렬 범위 `[1, 2, 3, 5]`에 `4`가 새롭게 추가된다면, `5`는 `4`보다 크기 때문에 switch가 필요하지만, `3`은 `4`보다 작기 때문에 switch는 필요가 없다. 그리고 `3`보다 앞에 있는 숫자들은 기존 패스에서 이미 정렬을 해놓았기 때문에 당연히 3보다는 작을 것이며, 더 이상의 `4`와 대소 비교는 무의미하다. 이 사실을 이용하면, 새롭게 추가되는 값보다 작은 숫자를 만나는 최초의 순간만 내무 반복문을 수행해도 된다.  
```text
[1, 2, 3, 5, 4, ...] 5 > 4 => switch

[1, 2, 3, 4, 5, ...] 3 < 4 => OK
```
```python
array = [3, 2, 1, 6, 5, 4, 9, 8, 7]

for end in range(1, len(array)):
    i = end
    while i > 0 and array[i-1] > array[i]:
        array[i-1], array[i] = array[i], array[i-1]
        i -= 1

print(array)
```
이 최적화를 적용하면, 정렬된 배열이 들어올 경우, O(N)의 시간 복잡도를 달성할 수 있다. 예를 들어, 다음과 같이 5개의 숫자가 배열이 들어오면 각 패스 당 단 한 번 총 4번의 비교만으로 해당 배열이 완전히 정렬되었음을 알아내고 삽입 정렬을 완료할 수 있다.
```text
[1, 2] : 1 < 2 => OK

[1, 2, 3] : 2 < 3 => OK

[1, 2, 3, 4] : 3 < 4 => OK

[1, 2, 3, 4, 5] : 4 < 5 => OK
```

<br>

### <span style='color:hsl(350, 100%, 66%);'>최적화2</span>
switch작업 없이 단순히 값들을 옮기는 것만으로 삽입 정렬을 구현할 수 있다. 앞의 값 정렬 범위에 추가시칸 값보다 큰 경우 값을 뒤로 밀다가 최초로 작은 값을 만나는 순간 그 뒤에 추가된 값을 꼽으면 된다.
```python
array = [3, 2, 1, 6, 5, 4, 9, 8, 7]

for end in range(1, len(array)):
    to_insert = array[end]
    i = end
    while i > 0 and array[i -1] > to_insert:
        array[i] = array[i -1]
        i -= 1
    array[i] = to_insert

print(array)
```

### <span style='color:hsl(350, 100%, 66%);'>결론</span>
삽입 정렬에서 코드를 최적화 하는 방법은 loop를 돌면서 사전에 정렬이 완료된 과정이 존재하면 그 이후 발생하는 불필요한 탐색(비교)를 없애면 좀 더 효율 적으로 사용할 수 있다는 것이다.