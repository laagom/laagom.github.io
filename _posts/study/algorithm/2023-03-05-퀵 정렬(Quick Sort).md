---
layout: post
title:  "[Algorithm] 퀵 정렬 (Quick Sort)"
subtitle:   "퀵 정렬 (Quick Sort"
date: 2023-03-05
categories: study
tags: algorithm
comments: true
related_posts:
image: /assets/img/lagom.png
---

# 퀵 정렬(Quick Sort)
이번에는 정렬 알고리즘에서 가장 유명한 알고리즘인 퀵 정렬(Quick Sort)에 대해 알아보려고 한다.

### <span style='color:hsl(350, 100%, 66%);'>개념</span>
병합 정렬과 마찬가지로 퀵정렬도 [`분할 정복기법`](https://velog.io/@arittung/Divide-and-Conquer)과 `재귀 알고리즘`을 이용한 정렬 알고리즘이다.

    *[분할 정복(divide and conquer) 방법]
    문제를 작은 2개의 문제로 분리하고 각각 해결한 후, 결과를 모아서 원래의 문제를 해결하는 전략이다.

퀵 정렬(Quick Sort)은 `불안정 정렬`에 속하며, 다른 원소와의 비교만으로 정렬을 수행하는 비교 정렬에 속한다. 또한 병합 정렬과 달리 퀵 정렬(Quick Sort)는 배열을 비균등하게 분할한다.

위의 설명만으로 보면 무슨 기법이니 재귀 알고리즘이니 사용하는 것들이 많아 어려워 보이지만 예제를 들어 코드를 살펴보면 어려울 것 없는 알고리즘이다.

이제 하나의 배열을 가지고 위에서 설명한 `퀵 정렬`이 어떻게 진행되는지 알아보자.

아래와 같이 1~7까지 총 7개의 숫자가 들어있는 배열이 존재한다.
```text
[6, 5, 1, 4, 7, 2, 3]
```
항상 정 가운데를 기준으로 분할을 하는 병합 정렬과 달리, 퀵 정렬은 흔히 `피벗(pivot)`이라고 불리는 임의의 기준 값을 사용한다. 여기서 말하는 `피벗(pivot)`하나의 기준점이라고 생각하면 된다. `피벗`값을 선택하는데는 여러가지 방법이 있지만 여기서는 간단한 설명을 위해 정 중앙에 위치한 `4`를 피벗으로 정하겠다. 그리고 다음과 같이 이 피벗값을 기준으로 피벗보다 작은 값의 그룹과 피벗보다 큰 값의 그룹으로 분리를 해준다.
```text
[3, 2, 1] < 4(pivot) < [7, 5, 6]
```
위와 같이 피벗보다 작은 값들은 모두 왼편으로, 큰 값들은 모두 오른편으로 나누면 기준 값은 정확히 정렬된 위치에 놓이게 된다. 또한 이러한 방식으로 분할을 해 놓으면 앞으로 더 이상 왼편에 있는 값들과 오른편에 있는 값들 간에는 비교를 할 필요가 없다. 따라서 반대편은 전혀 신경쓰지 않고 왼편이든 오른편이든 같은편 내의 값들 끼리 비교 후 정렬을 할 수 있다.

먼저 왼편을 동일한 방식으로 정렬해보자. 왼편의 정 가운데 값인 2가 피벗이며 작은 값 1은 왼편, 큰 값인 3은 오른쪽에 위치시킨다. 이제 양쪽 모두 값이 하나씩 밖에 없기 때문에 왼편의 정렬 작업이 완료되었다.
```text
[1] < 2(pivot) < [3]
```
오른편도 동일한 방식으로 정렬해보자. 오른편의 피벗 값은 5, 작은 값들은 왼편, 큰값들은 오른편
```text
[] < 5(pivot) < [7, 6]
```
오른편의 오른쪽에는 값이 2개가 있기 때문에 추가 정렬이 필요하며, 왼편에는 값이 없지만 오른편에는 여전히 두 개의 값이 있기 때문에, 동일한 방식의 정렬을 적용해 보겠다.
```text
[6] < 7(pivot) < []
```
마지막으로 지금까지 좌우로 분할했던 값들을 모두 합치면 다음과 같이 정렬된 배열을 얻을 수 있다.

```text
[1, 2, 3, 4, 5, 6, 7]
```
지금까지 살펴본 것과 같이 퀵 정렬은 배열을 피벗 값 기준으로 더 작은 값과 큰 값으로 반복적으로 분할하여 정렬해 나가는 방식을 취하고 있다.

<br>

### <span style='color:hsl(350, 100%, 66%);'>GIF로 이해하는 Quick Sort</span>

<img src="/assets/resources/quick-sort-001.gif">

<br>

### <span style='color:hsl(350, 100%, 66%);'>특징</span>
1. `파이썬(Python)의 list.sort()함수나 자바(Java)의 Arrays.sort()처럼 프로그래밍 언어 차원에서 기본적으로 지원되는 내장 정렬 함수는 대부분 퀵 정렬을 기본으로 한다.`
2. 일반적으로 원소의 개수가 적어질수록 나쁜 중간값이 선택될 확률이 높아지기 때문에, 원소의 개수에 따라 퀵 정렬에 다른 정렬을 혼합해서 쓰는 경우가 많다.
3. 병합 정렬과 퀵 정렬은 분할 정복과 재귀 알고리즘을 사용한다는 측면에서는 유사해보이지만, 내부적으로 정렬하는 방식에는 큰 차이가 있다.
4. 병합 정렬은 항상 정 중앙 기중으로 단순 분할 후 병합 시점에서 값의 비교 연산이 발생하는 반면, 퀵 정렬은 분할 시점부터 비교 연산이 일어나기 때문에 그 후 병합에 들어가는 비용이 매우 적거나 구현 방법에 따라서 아예 병합을 하지 않을 수 있다.

<br>

### <span style='color:hsl(350, 100%, 66%);'>복잡도</span>
1. 쿽 정렬의 성능은 pivot 값을 어떻게 선택하느냐에 크게 달라질 수 있다. 이상적인 경우에는 pivot 값을 기준으로 동일한 개수의 작은 값들과 큰 값들이 분할되어 병합 정렬과 마찬가지로 O(nlog(n))의 시간 복잡도를 가지게 된다.
2. 하지만 pivot 값을 기준으로 분할했을 때 값들이 한 편으로 크게 치우치게 되면, 퀵 정렬은 성능은 저하되게 되며, 최악의 경우 한 편으로만 모든 값이 몰리게 되어 O(n^2)의 시간 복잡도를 보이게 된다.
3. 따라서 상용 코드에서는 중앙값(median)에 가까운 pivot 값을 선택할 수 있는 섬세한 전략이 요구되며, 배열의 첫값과 중앙값 그리고 마지막값 중에 크기가 중간인 값을 사용하는 방법이 많이 사용된다.
4. 퀵 정렬은 공간 복잡도는 구현 방법에 따라 달라질 수 있는데, 입력 배열이 차지하는 메모리만을 사용하는 in-place sorting 방식으로 구현을 사용할 경우, O(log(n))의 공간 복잡도를 가진 코드의 구현이 가능하다.

<br>

### <span style='color:hsl(350, 100%, 66%);'>Python 코드</span>
위의 설명 처럼 기본 컨셉 그대로 코드로 구현할 수 있다. 먼저 리스트의 정 가운데 있는 값을 피벗 값으로 선택하고, 피벗 값보다 작은 값, 동일한 값 그리고 큰 값을 담아둘 3개의 리스트를 생성한다. 그리고 반복문을 통해 각 값을 피벗 비교 후에 해당하는 리스트에 추가시킨다. 그 다음 작은 값과 큰 값을 담고 있는 배열을 대상으로 퀵 정렬 함수를 재귀적으로 호출한다. 마지막으로 재귀 호출의 결과를 다시 크기 순으로 합치면 정렬된 리스트를 얻을 수 있다.
```python
def quick_sort(arry):
    if len(arry) <= 1:
        return arry
    pivot = arry[len(arry)//2]
    less_arry, equal_arry, greater_arry = [], [], []

    for num in arry:
        if num < pivot:
            less_arry.append(num)
        elif num > pivot:
            greater_arry.append(num)
        else:
            equal_arry.append(num)
    return quick_sort(less_arry) + equal_arry + quick_sort(greater_arry)

array = [1, 2, 3, 6, 5, 4, 9, 8, 7]
print(quick_sort(array))

'''
[1, 2, 3, 4, 5, 6, 7, 8, 9]
'''
```
<br>

### <span style='color:hsl(350, 100%, 66%);'>최적화</span>
위의 구현은 간결하고 이해하기 쉽지만 매번 재귀 호출될 때 마다 새로운 리스트를 생성하여 리턴하기 때문에 메모리 사용 측면에서 비효율적이다. 큰 사이즈의 입력 데이터를 다뤄야하는 상용 코드에서는 이러한 단점은 치명적으로 작용할 수 있기 때문에 추가 메모리 사용이 적은 [in-place 정렬](https://www.dalecoding.com/algorithms/quick-sort)이 선호한다.

처음부터 스스로 in-place 정렬을 구현하는 코드를 작성하기는 생각했던 것보다 쉽지 않을 수도 있다. 기존과 동일하게 값의 대소 비교를 위해서는 pivot 값을 사용하지만, 분할은 기준점은 pivot 값이 아닐 수도 있기 때문이다. 왜냐하면, pivot 값을 기준으로 대소 비교를 했을 때 좌측과 우측에 여유 공간이 딱 맞는 경우가 드물기 때문이다.

```python
def quick_sort(arry):
    def sort(low, high):
        if high <= low:
            return
        
        mid = partition(low, high)
        sort(low, mid-1)
        sort(mid, high)

    def partition(low, high):
        pivot = arry[(low+high) // 2]
        while low <= high:
            while arry[low] < pivot:
                low +=1
            while arry[high] > pivot:
                high -=1
            if low <= high:
                arry[low], arry[high] = arry[high], arry[low]
                low, high = low + 1, high -1
        return low

    return sort(0, len(arry)-1)

array = [1, 8, 3, 6, 5, 4, 9, 2, 7]
quick_sort(array)
print(array)

'''
[1, 2, 3, 4, 5, 6, 7, 8, 9]
'''
```
코드의 이해가 어려울 수 있기 때문에 글로 설명을 해보자. 메인 함수인 `quick_sort`는 크게 `sort()`와 `partition()`2개의 내부 함수로 나눠진다. `sort()`함수는 재귀 함수이며 정렬 범위를 시작 인덱스와 끝 인덱스로 인자를 받는다.

partition()함수는 정렬 범위를 인자로 받으며ㅕ 다음 로직을 따라서 좌우측의 값들을 정렬하고 분할 기준점의 인덱스를 리턴한다. 이 분할 기준점(mid)는 sort()를 재귀적으로 호출할 때 우측 리스트의 시작 인덱스로 사용된다.

- 리스트의 정 가운데 있는 값을 피벗을 선택한다.
- 시작 인덱스(low)는 계속 증가 시키고, 끝 인덱스(high)는 계속 감소 시키기위한 while 루프를 두 인덱스가 서로 교차해서 지나칠 때까지 반복시킨다.
    - 시작 인덱스(low)가 가리키는 값과 피벗 값을 비교해서 더 작은 경우 반복해서 시작 인덱스 값을 증가시킨다. (피벗보다 큰데 좌측에 있는 값을 찾기 위해)
    - 끝 인덱스(high)가 가리키는 값과 피벗 값을 비교해서 더 작은 경우 반복해서 끝 인덱스 값을 감소시킵니다. (피벗보다 작은데 우측에 있는 값을 찾기 위해)
    - 두 인덱스가 아직 서로 교차해서 지나치치 않았다면 시작 인덱스(low)가 가리키는 값과 끝 인덱스(high)가 가리키는 값을 상호 교대(switch) 시ek. (잘못된 위치에 있는 두 값의 위치를 바꾸기 위해)
    - 상호 교대 후, 다음 값을 가리키기 위해 두 인덱스를 각자 진행 방향으로 한 칸씩 이동 시킨다.
- 두 인덱스가 서로 교차해서 지나치게 되어 while 루프를 빠져나왔다면 다음 재귀 호출의 분할 기준점이될 시작 인덱스를 리턴한다.