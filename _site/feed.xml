<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>라곰(Lagom)</title>
    <description>백수개발자의 지식 저장소.
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 31 Jan 2023 22:12:23 +0900</pubDate>
    <lastBuildDate>Tue, 31 Jan 2023 22:12:23 +0900</lastBuildDate>
    <generator>Jekyll v3.8.6</generator>
    
      <item>
        <title>[Computer Science] 중앙처리장치(CPU) 작동 원리?</title>
        <description>&lt;h1 id=&quot;중앙처리장치cpu란&quot;&gt;중앙처리장치(CPU)란?&lt;/h1&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;중앙처리장치(CPU)&lt;/code&gt;는 명령어의 &lt;code class=&quot;highlighter-rouge&quot;&gt;해석&lt;/code&gt;과 자료의 &lt;code class=&quot;highlighter-rouge&quot;&gt;연산&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;비교&lt;/code&gt;등의 처리를 제어하는 컴퓨터 시스템의 핵심장치이다. 다양한 입력 장치로부터 정보를 입력받아 처리한 후, 그 결과를 출력장치로 보내는 일련의 과정을 &lt;code class=&quot;highlighter-rouge&quot;&gt;제어&lt;/code&gt;하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;조정&lt;/code&gt;하는 일을 수행한다. CUP는 사람의 두뇌와 같이 컴퓨터의 모든 시스템을 제어, 처리하는 가장 핵심적인 장치라고 할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;cpu-구성요소&quot;&gt;&lt;span style=&quot;color:hsl(350, 100%, 66%);&quot;&gt;CPU 구성요소&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;&lt;span&gt; &lt;img src=&quot;/assets/resources/cpu-architecture-001.png&quot; alt=&quot;Alt text&quot; /&gt; &lt;/span&gt;
출처: &lt;a href=&quot;https://mk28.tistory.com/15&quot;&gt;https://mk28.tistory.com/15&lt;/a&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;CPU는 크게 &lt;code class=&quot;highlighter-rouge&quot;&gt;제어장치&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;연산장치(ALU)&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;레지스터&lt;/code&gt;와 각 구성 요소를 연결하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;내부 버스&lt;/code&gt;로 구성되어 있다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-연산-장치&quot;&gt;🔖 연산 장치&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;명령어를 실행하기 위한 마이크로연산(산술연산과 논리연산)을 수행&lt;/li&gt;
  &lt;li&gt;연산에 필요한 데이터를 레지스터에서 가져오고 산술, 논리, 관계, 이동 등 다양한 연산을 수행&lt;/li&gt;
  &lt;li&gt;연산 결과를 다시 레지스터로 보냄&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-제어-장치&quot;&gt;🔖 제어 장치&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;명령어를 순서대로 실행할 수 있도록 제어하는 장치&lt;/li&gt;
  &lt;li&gt;주기억장치에서 프로그램 명령어를 꺼내 &lt;code class=&quot;highlighter-rouge&quot;&gt;해독&lt;/code&gt;하고, 그 결과에 따라 명령어 실행에 필요한 &lt;code class=&quot;highlighter-rouge&quot;&gt;제어 신호&lt;/code&gt;를 기억장치, 연산장치, 입출력장치로 보냄&lt;/li&gt;
  &lt;li&gt;또한 이들 장치가 보낸 신호를 받아 다음에 수행할 동작을 결정&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-레지스터&quot;&gt;🔖 레지스터&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;CPU(중앙 처리 장치)내에 있는 소규모의 고속 기억장치&lt;/li&gt;
  &lt;li&gt;명령어 주소, 코드, 연산에 필요한 데이터 련산 결과 등을 임시로 저장&lt;/li&gt;
  &lt;li&gt;용도에 따라 범용 레지스터와 특수 목적 레지스터로 구분&lt;/li&gt;
  &lt;li&gt;레지스터는 메모리 계층의 &lt;code class=&quot;highlighter-rouge&quot;&gt;최상위&lt;/code&gt;에 위치하며 &lt;code class=&quot;highlighter-rouge&quot;&gt;가장 빠른 속도&lt;/code&gt;로 접근 가능한 메모리이다.&lt;/li&gt;
  &lt;li&gt;중앙처리장치 종류에 따라 사용할 수 있는 레지스터 개수와 크기가 다름
    &lt;ul&gt;
      &lt;li&gt;범용 레지스터 : 연산에 필요한 데이터나 연산 결과를 임시로 저장&lt;/li&gt;
      &lt;li&gt;특수목적 레지스터 : 특별한 용도로 사용하는 레지스터&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-특수-목적-레지스터의-종류&quot;&gt;🔖 특수 목적 레지스터의 종류&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;MAR (메모리 주소 레지스터) : &lt;code class=&quot;highlighter-rouge&quot;&gt;읽기&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;쓰기&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;연산&lt;/code&gt;을 수행할 주기억장치 주소를 저장&lt;/li&gt;
  &lt;li&gt;PC (프로그램 카운터) : 다음에 실행될 &lt;code class=&quot;highlighter-rouge&quot;&gt;명령어의 주소&lt;/code&gt;를 저장&lt;/li&gt;
  &lt;li&gt;SP (스택 포인터) : &lt;code class=&quot;highlighter-rouge&quot;&gt;스택&lt;/code&gt;의 최상위 주소를 저장&lt;/li&gt;
  &lt;li&gt;IX (인덱스 레지스터) : 인덱스 주소 지정 방식에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;인덱스&lt;/code&gt;를 저장&lt;/li&gt;
  &lt;li&gt;IR (명령어 레지스터) : 명령어를 호출해서 해독하기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;현재 명령어&lt;/code&gt;를 임시로 저장&lt;/li&gt;
  &lt;li&gt;MBR (메모리 버퍼 레지스터) : &lt;code class=&quot;highlighter-rouge&quot;&gt;주기억장치의 내용&lt;/code&gt;을 임시로 저장하는 역할&lt;/li&gt;
  &lt;li&gt;AC (누산기) : 산술 논리 장치의 &lt;code class=&quot;highlighter-rouge&quot;&gt;연산 결과&lt;/code&gt;를 임시로 저장&lt;/li&gt;
  &lt;li&gt;PSR (프로그램 상태 레지스터) : &lt;code class=&quot;highlighter-rouge&quot;&gt;CPU의 현재 상태 정보&lt;/code&gt;를 저장&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;cpu-연산동작-과정&quot;&gt;&lt;span style=&quot;color:hsl(350, 100%, 66%);&quot;&gt;CPU 연산&amp;amp;동작 과정&lt;/span&gt;&lt;/h2&gt;

&lt;h3 id=&quot;-연산&quot;&gt;🔖 연산&lt;/h3&gt;

&lt;p&gt;CPU의 연산 순서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Fetch&lt;/code&gt;-&amp;gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Decode&lt;/code&gt;-&amp;gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Execute&lt;/code&gt;-&amp;gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Writeback&lt;/code&gt;으로 이루어지며 각 과정의 설명은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Fetch(&lt;code class=&quot;highlighter-rouge&quot;&gt;인출&lt;/code&gt;): 메모리상의 프로그램 카운터(PC)가 가리키는 명령어를 CPU가 가르키는 명령어를 CPU로 인출하여 적재&lt;/li&gt;
  &lt;li&gt;Decode(&lt;code class=&quot;highlighter-rouge&quot;&gt;해석&lt;/code&gt;): 명령어의 해석. 이 단계에서 명령어의 종류와 타겟 등을 판단한다.&lt;/li&gt;
  &lt;li&gt;Execute(&lt;code class=&quot;highlighter-rouge&quot;&gt;실행&lt;/code&gt;): 해석된 명령어에 따라 데이터에 대한 연산을 수행한다.&lt;/li&gt;
  &lt;li&gt;Writeback(&lt;code class=&quot;highlighter-rouge&quot;&gt;쓰기&lt;/code&gt;): 명령어대로 처리 완료된 데이터를 메모리에 기록한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-동작-과정&quot;&gt;🔖 동작 과정&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/resources/cpu-process-001.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;p&gt;(1) 보조기억장치에서 저장된 프로그램을 읽거나, 입력장치에서 입력받은 데이터를 주기억장치에서 읽는다.&lt;br /&gt;
(2) 주기억장치에서 읽어온 데이터를 중앙처리장치(CPU)가 읽고 처리한 후 다시 주기억장치로 보낸 후 저장한다.&lt;br /&gt;
(3) 주기억장치는 연산된 데이터를 출력장치에 보내거나 보조기억장치에 저장한다.&lt;br /&gt;
(4) 제어장치는 (1)-(3)과정에서 명령어가 순서대로 잘 실행되도록 제어하는 역할을 수행.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;cpu의-명령어&quot;&gt;&lt;span style=&quot;color:hsl(350, 100%, 66%);&quot;&gt;CPU의 명령어&lt;/span&gt;&lt;/h2&gt;

&lt;h3 id=&quot;-명령어-세트&quot;&gt;🔖 명령어 세트&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;명령어 세트는 CPU가 실행할 명령어의 집합이다.&lt;/li&gt;
  &lt;li&gt;명령어 세트는 실행할 연산을 나타내는 &lt;code class=&quot;highlighter-rouge&quot;&gt;연산 코드(Operation Code)&lt;/code&gt;와 연산에 필요한 데이터나 데이터의 저장 위치를 나타내는 &lt;code class=&quot;highlighter-rouge&quot;&gt;피연산자(Operand)&lt;/code&gt;로 구성된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-연산-코드-operation-code&quot;&gt;🔖 연산 코드 (Operation Code)&lt;/h3&gt;

&lt;p&gt;연산 코드는 실행하는 연산의 종류에 따라 다음과 같이 네 가지 기능으로 나뉜다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;연산 기능 : 사칙연산, 이동(shift), 보수 등의 산술연산과 논리곱, 논리합, 부정 등의 논리연산을 수행한다.&lt;/li&gt;
  &lt;li&gt;제어 기능 : 조건 분기와 무조건 분기 등을 사용하여 명령어의 실행 순서를 제어한다.&lt;/li&gt;
  &lt;li&gt;데이터 전달 기능 : 레지스터와 레지스터 사이, 레지스터와 주기억장치 사이에서 데이터를 전달한다.&lt;/li&gt;
  &lt;li&gt;입출력 기능 : 프로그램과 데이터를 주기억장치에 전달하고, 연산 결과는 출력장치에 전달한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-피연산자-operand&quot;&gt;🔖 피연산자 (Operand)&lt;/h3&gt;

&lt;p&gt;피연산자에는 주소, 숫자/문자, 논리 데이터 등을 저장할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;주소 : 기억장치 혹은 레지스터의 주소가 저장된다.&lt;/li&gt;
  &lt;li&gt;숫자/문자 : 숫자는 정수, 고정 소수점 수, 부동 소수점 수 및 각각의 코드로 저장되고 문자는 아스키코드로 저장된다.&lt;/li&gt;
  &lt;li&gt;논리 데이터 : 참 또는 거짓을 표현할 때 사용하며 비트나 플래그로 저장된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;명령어-사이클&quot;&gt;&lt;span style=&quot;color:hsl(350, 100%, 66%);&quot;&gt;명령어 사이클&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;CPU에서는 프로그램을 실행하기 위해 주기억장치에서 명령어를 순차적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;인출&lt;/code&gt;하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;해독&lt;/code&gt;하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;실행&lt;/code&gt;하는 과정을 반복하는데, CPU가 &lt;code class=&quot;highlighter-rouge&quot;&gt;주기억장치에서 한 번에 하나의 명령어를 인출하여 실행하는데 필요한 일련의 활동&lt;/code&gt;을 &lt;code class=&quot;highlighter-rouge&quot;&gt;명령어 사이클 (Instruction Cycle)&lt;/code&gt;이라고 한다.&lt;/p&gt;

&lt;p&gt;명령어 사이클은 &lt;code class=&quot;highlighter-rouge&quot;&gt;인출&lt;/code&gt; 사이클, &lt;code class=&quot;highlighter-rouge&quot;&gt;실행&lt;/code&gt; 사이클, &lt;code class=&quot;highlighter-rouge&quot;&gt;간접&lt;/code&gt; 사이클, &lt;code class=&quot;highlighter-rouge&quot;&gt;인터럽트&lt;/code&gt; 사이클로 세분화 시킬 수 있는데, &lt;code class=&quot;highlighter-rouge&quot;&gt;인출 사이클과 실행 사이클은 항상 수행&lt;/code&gt;되지만 / &lt;code class=&quot;highlighter-rouge&quot;&gt;간접 사이클과 인터럽트 사이클은 주소 지정방식이 필요할 때나 인터럽트 요구가 있을 때만&lt;/code&gt; 수행된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-인출사이클과-특수-목적-레지스터의-동작-과정&quot;&gt;🔖 인출사이클과 특수 목적 레지스터의 동작 과정&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/resources/sycle-process-001.jpeg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;프로그램 카운터(PC)에 저장된 주소를 메모리 주소 레지스터(MAR)로 전달 한다.&lt;/li&gt;
  &lt;li&gt;메모리 주소 레지스터(MAR)에 저장된 내용을 토대로 주기억장치의 해당 주소에서 명령어를 인출한다.&lt;/li&gt;
  &lt;li&gt;인출한 명령어를 메모리 버퍼 레지스터(MBR)에 저장한다.&lt;/li&gt;
  &lt;li&gt;다음 명령어를 인출하기 위해 프로그램 카운터 (PC)의 값을 증가 시킨다.&lt;/li&gt;
  &lt;li&gt;메모리 버퍼 레지스터(MBR)에 저장된 내용을 명령어 레지스터(IR)에 전달한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위 과정을 다음과 같이 표현하기도 한다.&lt;/p&gt;
&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;T0 : MAR &amp;lt;- PC
T1 : MBR &amp;lt;- M[MAR], PC &amp;lt;- PC + 1
T2 : IR &amp;lt;- MBR
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-실행-사이클과-특수-목적-레지스터의-동작-과정&quot;&gt;🔖 실행 사이클과 특수 목적 레지스터의 동작 과정&lt;/h3&gt;

&lt;p&gt;다음은 인출 사이클로부터 명령어를 인출한 이후 명령어를 실행하는 과정인 실행 사이클의 과정이다.
그 중에서도 더하기(ADD) 연산으로 과정을 살펴보자.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/resources/access-process-001.jpeg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;명령어 레지스터(IR)의 내용을 메모리 주소 레지스터(MAR)로 전달한다.&lt;/li&gt;
  &lt;li&gt;메모리에 저장된 데이터 값을 메모리 버퍼 레지스터(MBR)에 저장한다.&lt;/li&gt;
  &lt;li&gt;누산기(AC)에 저장된 값에 ADD연산을 실행한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;실행 사이클도 인출 사이클과 마찬가지로 다음과 같이 표현 할 수 있다.&lt;/p&gt;
&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ADD addr 명령어 연산

T0 : MAR &amp;lt;- IR(Addr)
T1 : MBR &amp;lt;- M[MAR]
T2 : AC &amp;lt;- AC + MBR
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;실행-사이클에서는-프로그램-카운터를-증가시키지-않는-이유&quot;&gt;실행 사이클에서는 프로그램 카운터를 증가시키지 않는 이유&lt;br /&gt;&lt;/h3&gt;
&lt;p&gt;인출 사이클과 다르게 실행 사이클에서는 프로그램 카운터(PC)를 증가시키지 않는데, &lt;code class=&quot;highlighter-rouge&quot;&gt;이미 인출이 진행 되고 명령어 실행만 하면 되는 상황&lt;/code&gt;이기 때문에 프로그램 카운터를 증가시킬 필요가 없다.
즉, 이미 인출이 되어 명령어 레지스터(IR)에 메모리 버퍼 레지스터(MBR)의 값이 저장된 상태라는 의미이다.&lt;/p&gt;
</description>
        <pubDate>Tue, 31 Jan 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/study/2023/01/31/%EC%A4%91%EC%95%99%EC%B2%98%EB%A6%AC%EC%9E%A5%EC%B9%98(CPU)-%EC%9E%91%EB%8F%99-%EC%9B%90%EB%A6%AC.html</link>
        <guid isPermaLink="true">http://localhost:4000/study/2023/01/31/%EC%A4%91%EC%95%99%EC%B2%98%EB%A6%AC%EC%9E%A5%EC%B9%98(CPU)-%EC%9E%91%EB%8F%99-%EC%9B%90%EB%A6%AC.html</guid>
        
        <category>computer_science</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[Computer Science] 컴퓨터란?</title>
        <description>&lt;h1 id=&quot;컴퓨터란&quot;&gt;컴퓨터란?&lt;/h1&gt;
&lt;p&gt;compute라는 어원을 가지며, &lt;code class=&quot;highlighter-rouge&quot;&gt;계산&lt;/code&gt;하는 기계라는 의미를 가지고 있다. 여기서 &lt;code class=&quot;highlighter-rouge&quot;&gt;계산&lt;/code&gt;이라는 것은 우리가 생각하는 산수가 아닌 좀더 포괄적인 개념이다. 그렇다면 계산하는 기계인 컴퓨터가 가지는 구성에 대해 알아보자. 컴퓨터 시스템은 크게 &lt;code class=&quot;highlighter-rouge&quot;&gt;하드웨어&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;소프트웨어&lt;/code&gt;로 나누어진다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;하드웨어: 컴퓨터를 구성하는 기계적 장치&lt;/li&gt;
  &lt;li&gt;소프트웨어: 하드웨어의 동작을 지시하고 제어하는 명령어 집합&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;하드웨어&quot;&gt;&lt;span style=&quot;color:hsl(350, 100%, 66%);&quot;&gt;하드웨어&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;하드웨어는 마우스, 키보드 등 실제로 존재하는 컴퓨터를 구성하는 장치를 말한다.
&lt;img src=&quot;/assets/resources/hardware-architecture-001.jpeg&quot; alt=&quot;Alt text&quot; /&gt;
창고: &lt;a href=&quot;http://jangun.com/study/ComputerScienceIntroduction.html&quot;&gt;http://jangun.com/study/ComputerScienceIntroduction.html&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;중앙처리장치(CPU)&lt;/li&gt;
  &lt;li&gt;기억장치: RAM, HDD&lt;/li&gt;
  &lt;li&gt;입출력장치: 마우스, 프린터, 모니터 등&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;실재하는 컴퓨터는 하드웨어는 &lt;code class=&quot;highlighter-rouge&quot;&gt;중앙처리장치(CPU)&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;기억장치&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;입출력장치&lt;/code&gt; 로 구성되어 있다. 이들은 시스템 버스로 연결이 되어 있으며, 시스템 버스는 데이터와 명령 제어 신호를 각 장치로 실어나르는 역할을 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-cpu이란&quot;&gt;🔖 CPU이란?&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;컴퓨터에서 `계산`을 담당하는 두뇌라고 생각하면 된다.  주기억장치에서 프로그램 명령어와 데이터를 읽어와 처리하고 명령어의 수행 순서를 제어한다. 중앙처리장치(CPU)는 비교와 연산을 담당하는 `산술논리연산장치(ALU)`와 명령어의 해석과 실행을 담당하는 `제어장치`, 속도가 빠른 데이터 기억장소인 `레지스터`로 구성되어 있다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;계산&lt;/code&gt;을 담당하는 만큼 &lt;code class=&quot;highlighter-rouge&quot;&gt;처리속도가 그만큼 빠르다.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-ram이란&quot;&gt;🔖 RAM이란?&lt;/h3&gt;
&lt;p&gt;우리가 수학문제를&lt;code class=&quot;highlighter-rouge&quot;&gt;노트&lt;/code&gt;하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;연필&lt;/code&gt;을 이용하여 풀듯, CPU가 하는 계산을 &lt;code class=&quot;highlighter-rouge&quot;&gt;노트&lt;/code&gt;와&lt;code class=&quot;highlighter-rouge&quot;&gt;연필&lt;/code&gt;을 이용하여 도와주는 역할을 &lt;code class=&quot;highlighter-rouge&quot;&gt;RAM&lt;/code&gt;이라고 생각하면 된다. 내 두뇌만을 이용해서 문제를 풀 수 있지만 노트와 연필을 이용한 보조장치를 이용하면 더 손쉬운 문제풀이가 가능하기 때문에 RAM이라는 하드웨어가 존재하는 것이다.&lt;/p&gt;

&lt;h3 id=&quot;-보조장치란&quot;&gt;🔖 보조장치란?&lt;/h3&gt;
&lt;p&gt;좁은 의미의 컴퓨터는 &lt;code class=&quot;highlighter-rouge&quot;&gt;CPU&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;RMA&lt;/code&gt;을 합친거라고 생각하면 나머지는 보조장치라고 할 수 있다.(입출력장치, 보조 기억장치)&lt;/p&gt;

&lt;h3 id=&quot;-보조-기억-장치hdd-sdd란&quot;&gt;🔖 보조 기억 장치(HDD, SDD)란?&lt;/h3&gt;
&lt;p&gt;RAM도 사실상 용량이 그렇게 크지 않기 때문에 &lt;code class=&quot;highlighter-rouge&quot;&gt;보조 기억 장치&lt;/code&gt;를 이용한다. 우리가 자주 접하는 컴퓨터 용량이나 외장 하드, SSD가 이에 포함된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-시스템-버스&quot;&gt;🔖 시스템 버스&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;하드웨어 구성 요소를 물리적으로 연결하는 선을 의미 각 구성요소가 다른 구성요소로 데이터를 보낼 수 있도록 통로가 되어준다. 용도에 따라 `데이터 버스`, `주소 버스`, `제어 버스`로 나누어 진다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;데이터 버스 : 중앙처리장치와 기타 장치 사이에서 데이터를 전달하는 통로&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;기억장치와 입출력장치의 명령어와 데이터를 중앙처리장치로 보내거나 중앙처리장치의 연산 결과를 기억장치와 입출력장치로 보내는 &lt;code class=&quot;highlighter-rouge&quot;&gt;양방향&lt;/code&gt;버스&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;주소 버스 : 데이터를 정확히 실어나르기 위해서는 기억 장치 &lt;code class=&quot;highlighter-rouge&quot;&gt;주소&lt;/code&gt;를 정해주어야 함.&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;주소 버스는 중앙처리장치가 주기억 장치나 입출력장치로 기억장치 주소를 전달하는 통로이기 때문에 &lt;code class=&quot;highlighter-rouge&quot;&gt;단방향&lt;/code&gt;버스임&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;제어 버스 : 주소 버스와 데이터 버스는 모든 장치에 공유되기 때문에 이를 제어할 수단이 필요&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;제어 버스는 중앙처리 장치가 기억장치나 입출력장치에 제어 신호를 전달하는 통로임&lt;/li&gt;
    &lt;li&gt;제어 신호 종류 : 기억장치 읽기 및 쓰기, 버스 요청 및 승인, 인터럽트 요청 및 승인, 클락, 리셋 등&lt;/li&gt;
    &lt;li&gt;제어 버스는 읽기 동작과 쓰기 동작을 모두 수행하기 때문에 &lt;code class=&quot;highlighter-rouge&quot;&gt;양방향&lt;/code&gt;버스임&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;소프트웨어&quot;&gt;&lt;span style=&quot;color:hsl(350, 100%, 66%);&quot;&gt;소프트웨어&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;소프트웨어는 눈으로는 볼 수 있지만 손으로는 만질 수 없는 것들을 의민한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;시스템 소프트웨어: 운영체제, 컴파일러&lt;/li&gt;
  &lt;li&gt;응용 소프트웨어: 워드프로세서, 스프레드시트&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 25 Jan 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/study/2023/01/25/%EC%BB%B4%ED%93%A8%ED%84%B0%EB%9E%80.html</link>
        <guid isPermaLink="true">http://localhost:4000/study/2023/01/25/%EC%BB%B4%ED%93%A8%ED%84%B0%EB%9E%80.html</guid>
        
        <category>computer_science</category>
        
        
        <category>study</category>
        
      </item>
    
      <item>
        <title>[Algorithm] 거품 정렬 (Bubble Sort)</title>
        <description>&lt;h1 id=&quot;거품-정렬-bubble-sort&quot;&gt;거품 정렬 (Bubble Sort)&lt;/h1&gt;

&lt;h2 id=&quot;개념&quot;&gt;&lt;span style=&quot;color:hsl(350, 100%, 66%);&quot;&gt;개념&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;거품 정렬은 뒤에서 부터 앞으로 정렬을 해나가는 구조를 가지고 있다. (오름차순)즉, 배열 내의 인접한 값들을 앞뒤로 비교하며 자리를 바꾸는데 맨 뒷자리로 제일 큰 값을 보내는 작업을 수행한다. 이렇게 하나씩 큰 값을 뒤쪽으로 보내 채워 나가며 앞으로 정렬해 왔을 때 작은 수 부터 큰 수 까지 오름차순으로 정렬된 배열을 가지는 정렬이다. 큰 값을 계속해서 뒤로 보내는 모습이 마치 방울이 이동하는 것과 같이 보여서 거품 정렬이라는 이름이 붙어졌다.&lt;/p&gt;

&lt;p&gt;이제 하나의 배열을 가지고 위에서 설명한 거품정렬이 어떻게 진행되는지 알아보자. 다음과 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;부터 &lt;code class=&quot;highlighter-rouge&quot;&gt;5&lt;/code&gt;까지 총 5개의 숫자가 들어있는 배열이 존재한다.&lt;/p&gt;
&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[3, 2, 4, 5, 1]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;먼저 3, 2를 비교, 3이 2보다 크기 때문에 자리를 바꾸며 큰 값을 뒤로 보내준다.&lt;/p&gt;
&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[3, 2, 4, 5, 1]

3 &amp;gt; 2 =&amp;gt; switch 
[2, 3, 4, 5, 1]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;그 다음 3, 4를 비교, 3은 4보다 크지 않기 때문에 그대로 유지한다.&lt;/p&gt;
&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[2, 3, 4, 5, 1]

3, 4 =&amp;gt; keep     
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;그 다음 4, 5를 비교, 4는 5보다 크지 않기 때문에 그대로 유지한다.&lt;/p&gt;
&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[2, 3, 4, 5, 1]

4, 5 =&amp;gt; keep
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;그 다음 5, 1를 비교, 5는 1보다 크기 때문에 자리를 바꾸며 큰 값을 뒤로 보내준다.&lt;/p&gt;
&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[2, 3, 4, 5, 1]

5 &amp;gt; 1 =&amp;gt; switch
[2, 3, 4, 1, 5]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 값을 처음부터 비교해가며 앞의 값이 뒤의 값보다 큰 경우 자리를 바꿔주면 제일 큰 값을 맨 뒤로 보내줄 수 있다. 위의 과정은 제일 큰 값을 맨 뒤로 보내주는 작업이며 그다음은 두번째 큰 값을 제일 큰 값 앞으로 보내주는 과정을 진행해 주면 된다.&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;origin: [3, 2, 4, 5, 1]
-----------------------
loop 1: [2, 3, 4, 1, 5]
                   *
loop 2: [2, 3, 1, 4, 5]
                *  *
loop 3: [2, 1, 3, 4, 5]
             *  *  *
loop 4: [1, 2, 3, 4, 5]
          *  *  *  *
loop 5: [1, 2, 3, 4, 5]
       *  *  *  *  *
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;gif로-이해하는-bubble-sort&quot;&gt;&lt;span style=&quot;color:hsl(350, 100%, 66%);&quot;&gt;GIF로 이해하는 Bubble Sort&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/assets/resources/bubble-sort-001.gif&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;특징&quot;&gt;&lt;span style=&quot;color:hsl(350, 100%, 66%);&quot;&gt;특징&lt;/span&gt;&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;거품 정렬은 점점 큰 값들이 뒤에서 앞으로 쌓여 이동하기 때문에 정렬의 범위가 하나씩 줄어든다. 다음 loop에서 제일 뒤로 간 큰 값은 비교를 할 필요가 없기 때문이다.&lt;/li&gt;
  &lt;li&gt;제일 작은 값을 맨 앞으로 이동시키는 선택 정렬과 정렬 방향이 반대이다.&lt;/li&gt;
  &lt;li&gt;선택정렬에 비해 자리 변경이 더 많이 일어난다.&lt;/li&gt;
  &lt;li&gt;위의 loop 4, loop 5를 보면 필요없는 과정이 있어 최적화가 필요하다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;복잡도&quot;&gt;&lt;span style=&quot;color:hsl(350, 100%, 66%);&quot;&gt;복잡도&lt;/span&gt;&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;거품 정렬은 별도의 추가 공간을 사용하지 않고 배열안에서 값들의 위치가 변경되기 때문에 &lt;code class=&quot;highlighter-rouge&quot;&gt;0(1)&lt;/code&gt;의 공간 복잡도를 가진다.&lt;/li&gt;
  &lt;li&gt;시간 복잡도는 반복문을 통해 맨 뒤에서 맨 앞까지 모든 인덱스에 접근하기 때문에 기본적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;0(N)&lt;/code&gt; 시간을 소모하며, 하나의 루프에서는 인접한 값들의 대소 비교 및 자리 교대를 위해서 &lt;code class=&quot;highlighter-rouge&quot;&gt;0(N)&lt;/code&gt; 시간을 필요하게 된다. 따라서 거품 정렬은 총 &lt;code class=&quot;highlighter-rouge&quot;&gt;0(N^2)&lt;/code&gt;의 시간 복잡도를 가진다.&lt;/li&gt;
  &lt;li&gt;정렬이 이미 완료된 배열인 경우에는 0(N) 시간 복잡도를 가진다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;python-코드&quot;&gt;&lt;span style=&quot;color:hsl(350, 100%, 66%);&quot;&gt;Python 코드&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;선택 정렬과 마찬가지로 두 개의 반복문이 필요하다. 내부 반복문에서는 첫번째 값부터 이전 패스에서 뒤로 보내놓은 값이 있는 위치 전까지 앞뒤 값을 계속해서 비교해나가면서 앞의 값이 뒤의 값보다 클 경우 자리 변경(switch)을 한다. 외부 반복문에서는 뒤에서 부터 앞으로 정렬 범위를 &lt;code class=&quot;highlighter-rouge&quot;&gt;n-1&lt;/code&gt;부터 &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; 까지 줄여나간다.&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;bubbleSort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;bubble_arry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bubbleSort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bubble_arry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;최적화&quot;&gt;&lt;span style=&quot;color:hsl(350, 100%, 66%);&quot;&gt;최적화&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;이전 loop에서 앞뒤 자리 변경(switch)이 한 번도 일어나지 않았다면 정렬도지 않는 값이 하나도 없었다고 할 수 있다. 따라서 이러한 경우 loop를 수행하지 않아도 된다.&lt;/p&gt;
&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;origin: [1, 2, 3, 5, 4]
------------------------
 loop 1: [1, 2, 3, 4, 5] =&amp;gt; switch 있음
                      *
 loop 2: [1, 2, 3, 4, 5] =&amp;gt; switch 없음
                   *  *
=&amp;gt; 이전 패스에서 loop이 한 번도 없었으니 종료
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;timeit&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;time_decorator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;exec_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kwargs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;start_time&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;timeit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;default_timer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kwargs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;timeit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;default_timer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start_time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exec_func&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time_decorator&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;bubbleSort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;bubble_arry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bubbleSort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bubble_arry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;최적화-1&quot;&gt;&lt;span style=&quot;color:hsl(350, 100%, 66%);&quot;&gt;최적화&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;최적화 하여 코드를 변경하고 시간을 측정해 봤을때 실행 속도가 많이 빨라졌다는 느낌은 없었다. 하지만 최적화 전보다 빈번하게 더 시간이 단축되어 실행되는 경우가 발생한 것을 보니 코드 최적화가 조금은 된 것으로 보인다.&lt;/p&gt;
</description>
        <pubDate>Wed, 25 Jan 2023 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/study/2023/01/25/%EA%B1%B0%ED%92%88-%EC%A0%95%EB%A0%AC(Bubble-Sort).html</link>
        <guid isPermaLink="true">http://localhost:4000/study/2023/01/25/%EA%B1%B0%ED%92%88-%EC%A0%95%EB%A0%AC(Bubble-Sort).html</guid>
        
        <category>algorithm</category>
        
        
        <category>study</category>
        
      </item>
    
  </channel>
</rss>
