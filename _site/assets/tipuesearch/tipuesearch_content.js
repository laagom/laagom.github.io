var tipuesearch = {"pages": [{
    "title": "[Computer Science] 컴퓨터란?",
    "text": "컴퓨터란? compute라는 어원을 가지며, 계산하는 기계라는 의미를 가지고 있다. 여기서 계산이라는 것은 우리가 생각하는 산수가 아닌 좀더 포괄적인 개념이다. 그렇다면 계산하는 기계인 컴퓨터가 가지는 구성에 대해 알아보자. 컴퓨터 시스템은 크게 하드웨어와 소프트웨어로 나누어진다. 하드웨어: 컴퓨터를 구성하는 기계적 장치 소프트웨어: 하드웨어의 동작을 지시하고 제어하는 명령어 집합 하드웨어 하드웨어는 마우스, 키보드 등 실제로 존재하는 컴퓨터를 구성하는 장치를 말한다. 창고: http://jangun.com/study/ComputerScienceIntroduction.html 중앙처리장치(CPU) 기억장치: RAM, HDD 입출력장치: 마우스, 프린터, 모니터 등 실재하는 컴퓨터는 하드웨어는 중앙처리장치(CPU), 기억장치, 입출력장치 로 구성되어 있다. 이들은 시스템 버스로 연결이 되어 있으며, 시스템 버스는 데이터와 명령 제어 신호를 각 장치로 실어나르는 역할을 한다. 🔖 CPU이란? 컴퓨터에서 `계산`을 담당하는 두뇌라고 생각하면 된다. 주기억장치에서 프로그램 명령어와 데이터를 읽어와 처리하고 명령어의 수행 순서를 제어한다. 중앙처리장치(CPU)는 비교와 연산을 담당하는 `산술논리연산장치(ALU)`와 명령어의 해석과 실행을 담당하는 `제어장치`, 속도가 빠른 데이터 기억장소인 `레지스터`로 구성되어 있다. 계산을 담당하는 만큼 처리속도가 그만큼 빠르다. 🔖 RAM이란? 우리가 수학문제를노트하고 연필을 이용하여 풀듯, CPU가 하는 계산을 노트와연필을 이용하여 도와주는 역할을 RAM이라고 생각하면 된다. 내 두뇌만을 이용해서 문제를 풀 수 있지만 노트와 연필을 이용한 보조장치를 이용하면 더 손쉬운 문제풀이가 가능하기 때문에 RAM이라는 하드웨어가 존재하는 것이다. 🔖 보조장치란? 좁은 의미의 컴퓨터는 CPU, RMA을 합친거라고 생각하면 나머지는 보조장치라고 할 수 있다.(입출력장치, 보조 기억장치) 🔖 보조 기억 장치(HDD, SDD)란? RAM도 사실상 용량이 그렇게 크지 않기 때문에 보조 기억 장치를 이용한다. 우리가 자주 접하는 컴퓨터 용량이나 외장 하드, SSD가 이에 포함된다. 🔖 시스템 버스 하드웨어 구성 요소를 물리적으로 연결하는 선을 의미 각 구성요소가 다른 구성요소로 데이터를 보낼 수 있도록 통로가 되어준다. 용도에 따라 `데이터 버스`, `주소 버스`, `제어 버스`로 나누어 진다. 데이터 버스 : 중앙처리장치와 기타 장치 사이에서 데이터를 전달하는 통로 기억장치와 입출력장치의 명령어와 데이터를 중앙처리장치로 보내거나 중앙처리장치의 연산 결과를 기억장치와 입출력장치로 보내는 양방향버스 주소 버스 : 데이터를 정확히 실어나르기 위해서는 기억 장치 주소를 정해주어야 함. 주소 버스는 중앙처리장치가 주기억 장치나 입출력장치로 기억장치 주소를 전달하는 통로이기 때문에 단방향버스임 제어 버스 : 주소 버스와 데이터 버스는 모든 장치에 공유되기 때문에 이를 제어할 수단이 필요 제어 버스는 중앙처리 장치가 기억장치나 입출력장치에 제어 신호를 전달하는 통로임 제어 신호 종류 : 기억장치 읽기 및 쓰기, 버스 요청 및 승인, 인터럽트 요청 및 승인, 클락, 리셋 등 제어 버스는 읽기 동작과 쓰기 동작을 모두 수행하기 때문에 양방향버스임 소프트웨어 소프트웨어는 눈으로는 볼 수 있지만 손으로는 만질 수 없는 것들을 의민한다. 시스템 소프트웨어: 운영체제, 컴파일러 응용 소프트웨어: 워드프로세서, 스프레드시트",
    "tags": "computer_science study",
    "url": "/study/2023/01/25/%EC%BB%B4%ED%93%A8%ED%84%B0%EB%9E%80.html"
  },{
    "title": "[Algorithm] 거품 정렬 (Bubble Sort)",
    "text": "거품 정렬 (Bubble Sort) 개념 거품 정렬은 뒤에서 부터 앞으로 정렬을 해나가는 구조를 가지고 있다. (오름차순)즉, 배열 내의 인접한 값들을 앞뒤로 비교하며 자리를 바꾸는데 맨 뒷자리로 제일 큰 값을 보내는 작업을 수행한다. 이렇게 하나씩 큰 값을 뒤쪽으로 보내 채워 나가며 앞으로 정렬해 왔을 때 작은 수 부터 큰 수 까지 오름차순으로 정렬된 배열을 가지는 정렬이다. 큰 값을 계속해서 뒤로 보내는 모습이 마치 방울이 이동하는 것과 같이 보여서 거품 정렬이라는 이름이 붙어졌다. 이제 하나의 배열을 가지고 위에서 설명한 거품정렬이 어떻게 진행되는지 알아보자. 다음과 같이 1부터 5까지 총 5개의 숫자가 들어있는 배열이 존재한다. [3, 2, 4, 5, 1] 먼저 3, 2를 비교, 3이 2보다 크기 때문에 자리를 바꾸며 큰 값을 뒤로 보내준다. [3, 2, 4, 5, 1] 3 &gt; 2 =&gt; switch [2, 3, 4, 5, 1] 그 다음 3, 4를 비교, 3은 4보다 크지 않기 때문에 그대로 유지한다. [2, 3, 4, 5, 1] 3, 4 =&gt; keep 그 다음 4, 5를 비교, 4는 5보다 크지 않기 때문에 그대로 유지한다. [2, 3, 4, 5, 1] 4, 5 =&gt; keep 그 다음 5, 1를 비교, 5는 1보다 크기 때문에 자리를 바꾸며 큰 값을 뒤로 보내준다. [2, 3, 4, 5, 1] 5 &gt; 1 =&gt; switch [2, 3, 4, 1, 5] 이렇게 값을 처음부터 비교해가며 앞의 값이 뒤의 값보다 큰 경우 자리를 바꿔주면 제일 큰 값을 맨 뒤로 보내줄 수 있다. 위의 과정은 제일 큰 값을 맨 뒤로 보내주는 작업이며 그다음은 두번째 큰 값을 제일 큰 값 앞으로 보내주는 과정을 진행해 주면 된다. origin: [3, 2, 4, 5, 1] ----------------------- loop 1: [2, 3, 4, 1, 5] * loop 2: [2, 3, 1, 4, 5] * * loop 3: [2, 1, 3, 4, 5] * * * loop 4: [1, 2, 3, 4, 5] * * * * loop 5: [1, 2, 3, 4, 5] * * * * * GIF로 이해하는 Bubble Sort 특징 거품 정렬은 점점 큰 값들이 뒤에서 앞으로 쌓여 이동하기 때문에 정렬의 범위가 하나씩 줄어든다. 다음 loop에서 제일 뒤로 간 큰 값은 비교를 할 필요가 없기 때문이다. 제일 작은 값을 맨 앞으로 이동시키는 선택 정렬과 정렬 방향이 반대이다. 선택정렬에 비해 자리 변경이 더 많이 일어난다. 위의 loop 4, loop 5를 보면 필요없는 과정이 있어 최적화가 필요하다. 복잡도 거품 정렬은 별도의 추가 공간을 사용하지 않고 배열안에서 값들의 위치가 변경되기 때문에 0(1)의 공간 복잡도를 가진다. 시간 복잡도는 반복문을 통해 맨 뒤에서 맨 앞까지 모든 인덱스에 접근하기 때문에 기본적으로 0(N) 시간을 소모하며, 하나의 루프에서는 인접한 값들의 대소 비교 및 자리 교대를 위해서 0(N) 시간을 필요하게 된다. 따라서 거품 정렬은 총 0(N^2)의 시간 복잡도를 가진다. 정렬이 이미 완료된 배열인 경우에는 0(N) 시간 복잡도를 가진다. Python 코드 선택 정렬과 마찬가지로 두 개의 반복문이 필요하다. 내부 반복문에서는 첫번째 값부터 이전 패스에서 뒤로 보내놓은 값이 있는 위치 전까지 앞뒤 값을 계속해서 비교해나가면서 앞의 값이 뒤의 값보다 클 경우 자리 변경(switch)을 한다. 외부 반복문에서는 뒤에서 부터 앞으로 정렬 범위를 n-1부터 1 까지 줄여나간다. def bubbleSort(array): length = len(array)-1 for i in range(length): for j in range(length-i): if array[j] &gt; array[j+1]: array[j],array[j+1] = array[j+1], array[j] return array bubble_arry = [10, 1, 9, 2, 8, 3, 7, 4, 6, 5] print(bubbleSort(bubble_arry)) 최적화 이전 loop에서 앞뒤 자리 변경(switch)이 한 번도 일어나지 않았다면 정렬도지 않는 값이 하나도 없었다고 할 수 있다. 따라서 이러한 경우 loop를 수행하지 않아도 된다. origin: [1, 2, 3, 5, 4] ------------------------ loop 1: [1, 2, 3, 4, 5] =&gt; switch 있음 * loop 2: [1, 2, 3, 4, 5] =&gt; switch 없음 * * =&gt; 이전 패스에서 loop이 한 번도 없었으니 종료 import timeit def time_decorator(func): def exec_func(*args, **kwargs): start_time = timeit.default_timer() result = func(*args, **kwargs) print(timeit.default_timer() - start_time) return result return exec_func @time_decorator def bubbleSort(array): length = len(array)-1 for i in range(length): switch = False for j in range(length-i): if array[j] &gt; array[j+1]: array[j], array[j+1] = array[j+1], array[j] switch = True if not switch: break return array bubble_arry = [10, 1, 9, 2, 8, 3, 7, 4, 6, 5] print(bubbleSort(bubble_arry)) 최적화 최적화 하여 코드를 변경하고 시간을 측정해 봤을때 실행 속도가 많이 빨라졌다는 느낌은 없었다. 하지만 최적화 전보다 빈번하게 더 시간이 단축되어 실행되는 경우가 발생한 것을 보니 코드 최적화가 조금은 된 것으로 보인다.",
    "tags": "algorithm study",
    "url": "/study/2023/01/25/%EA%B1%B0%ED%92%88-%EC%A0%95%EB%A0%AC(Bubble-Sort).html"
  }]};
