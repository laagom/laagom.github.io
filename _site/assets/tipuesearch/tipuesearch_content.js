var tipuesearch = {"pages": [{
    "title": "[Data Structure] 해시(Hash)",
    "text": "해시(Hash) 일반적으로 말하는 해시(Hash)는 해시 테이블(Hash Table)로 Key와 Value를 매핑해서 데이터를 저장하는 자료구조이다. Python에서는 기본적으로 제공되는 딕셔너리 자료형이 해시 테이블과 동일한 구조를 가진다. 해시에 대해 자세히 학습하기 전에 해시에 사용되는 용어 먼저 알아보고 가자 용어 키(Key): 고유의 값으로 해시 함수의 Input에 해당. 다양한 길이의 값이 될 수 있다. 해시 테이블(Hash Table) or 해시 맵(Hash Map): Key와 Value를 매핑해서 데이터를 저장하는 자료구조이다. 해시 함수(Hash Function): 임의의 값을 고정된 길이의 데이터로 변환하는 함수. 다양한 길이의 키를 고정된 길이의 해시로 변환시키므로 저장소를 효율적으로 운영할 수 있게 해준다. 해시(Hash): 해시 함수의 output으로 해시 값과 매칭되어 버킷에 저장된다. 해시 값(Hash Value): 키에 해시 함수를 적용하여 얻는 해시 값 버킷(Bucket): 한 개의 데이터를 저장할 수 있는 공간 다양한 길이를 가지고 있는 Key값에 해시 함수를 적용시키면 00, 01, 02와 같이 고정된 길이의 데이터로 변환된다. 이렇게 변환된 데이터가 해시 값이고, 버킷에는 키와 매핑된 원래 데이터를 저장하게 된다. 결과적으로 변환된 키값과 버킷에 매핑되어 있는 데이터를 해시라 하고 이러한 자료구조를 해시 테이블이라고 한다. 사용 용도 위에서 해시는 Key, Value구조로 데이터를 저장하는 해시 테이블이라고 설명을 했다. 이러한 해시는 언제 사용하면 좋을까? 🔖 리스트를 사용할 수 없을 때 리스트는 숫자 인덱스를 이용하여 원소에 접근하는데 list[1]의 형식으로 접근은 가능하지만 list[‘a’]와 같은 형식으로는 접근이 불가능하다. 즉, 인덱스 값을 숫자가 아닌 문자열, Boolean 등과 같은 자료형을 사용할 때 해시(Python에서의 딕셔너리)를 사용하면 좋다. 🔖 빠른 접근/탐색이 필요할 때 해시(Python에서의 딕셔너리) 함수의 시간복잡도는 대부분 O(1)이므로 아주 빠른 자료구조이므로 List보다 빠른 접근과 탑색이 필요할 때 사용하면 좋다. 🔖 집계가 필요할 때 원소의 개수를 세는 문제는 코딩 테스트에서 많이 출제되는 문제이다. 이때 해시와, Collections모듈의 Counter 클래스를 사용하면 아주 빠르게 문제를 풀 수 있을 것이다. 딕셔너리와 리스트의 시간 복잡도 차이 위의 설명에서 딕셔너리의 시간 복잡도는 대부분 O(1)을 갖는다고 했다. 아래 표를 이용하여 리스트와 시간복잡도를 비교해 보자. Operation Dictionary List Get Item O(1) O(1) Inser Item O(1) O(1)~O(N) Update Item O(1) O(1) Delete Item O(1) O(1)~O(N) Search Item O(1) O(N) List에 비해 Dictionary가 매우 빠른 시간복잡도를 갖는 것을 볼 수 있다. 즉, 원소를 넣거나 삭제, 찾는 일이 많을 때에는 딕셔너리를 사용하는 것이 좋다. ❊ Python3.7 이상부터 딕셔너리는 원소가 들어온 순서를 보장하게 되었다. 반면, Python3.7미만은 순서를 보장하지 않는다고 한다. Dictionary 사용법 🔖 Init {}를 사용하거나 dict함수 호출 시 빈 딕셔너리를 선언할 수 있다. Key-Value쌍을 가지는 Dictionary선언도 바로 가능하다. # 딕셔너리 생성하기 init_dict1 = {} init_dict2 = dict() print(init_dict1) # {} print(init_dict2) # {} # Key-Value쌍을 가지는 특정 dictionary 선언 Lagom = { 'name' : '조OO', 'age' : 32, 'marital' : False, 'height' : 183, } Lagom ''' {'name': '조OO', 'age': 32, 'marital': False, 'height': 183} ''' # dictionary를 value로 가지는 dictionary 선언 Lagom = { 'name' : '조OO', 'age' : 32, 'marital' : False, 'height' : 183, 'Friend' : { 'MinWook', 'Jinho' } } Lagom ''' {'name': '조OO', 'age': 32, 'marital': False, 'height': 183, 'Friend': {'Jinho', 'MinWook'}} ''' 🔖 Get Dictionary에서 원소를 가져오는 2가지 방법 [], get메소드 가 존재한다. get메소드는 get(key, x)로 사용을 할 수 있으며, key가 존재하지 않을 때 x를 반환해준다. ```python [] 기호로 원소 가져오기 Lagom = { ‘name’ : ‘조OO’, ‘age’ : 32, ‘marital’ : False, ‘height’ : 183, ‘Friend’ : { ‘MinWook’, ‘Jinho’ } } Lagom[‘name’] ’’’ ‘조OO’ ‘’’ ```python # get 메소드로 원소 가져오기 # 딕셔너리에 해당 key가 없는 경우 error를 발생하는 대신 특정 값을 가져오게 하기 Lagom = { 'name' : '조OO', 'age' : 32, 'marital' : False, 'height' : 183, 'Friend' : { 'MinWook', 'Jinho' } } Lagom.get('weight', 80) ''' 80 ''' 🔖 Set Dictionary에 값을 넣거나 수정할 때 []를 사용한다. # 값 넣기 Lagom = { 'name' : '조OO', 'age' : 32, 'marital' : False, 'height' : 183, 'Friend' : { 'MinWook', 'Jinho' } } Lagom['weight'] = 80 Lagom ''' {'name': '조OO', 'age': 32, 'marital': False, 'height': 183, 'Friend': {'Jinho', 'MinWook'}, 'weight': 80} ''' # 값 수정 Lagom = { 'name' : '조OO', 'age' : 32, 'marital' : False, 'height' : 183, 'Friend' : { 'MinWook', 'Jinho' } } Lagom['name'] = '박OO' Lagom ''' {'name': '박OO', 'age': 32, 'marital': False, 'height': 183, 'Friend': {'Jinho', 'MinWook'}} ''' 🔖 Delete Dictionary에서 특정 key값을 지울때 아래와 같은 방법을 이용할 수 있다. del dict_obj[key] del 은 키워드로써, 만약 Dictionary에 key가 없다면 keyError가 발생한다. pop(key, [default]) pop은 메소드로써, pop메소드는 key값에 해당하는 value를 리턴한다. key가 없다면 두번째 파라미터인 default를 리턴한다. 만약 default설정하지 않았을 경우 keyError가 발생한다. ```python del 이용하기 - 키가 있는 경우 Lagom = { ‘name’ : ‘조OO’, ‘age’ : 32, ‘marital’ : False, ‘height’ : 183, ‘Friend’ : { ‘MinWook’, ‘Jinho’ } } del Lagom[‘name’] Lagom ’’’ {‘age’: 32, ‘marital’: False, ‘height’: 183, ‘Friend’: {‘Jinho’, ‘MinWook’}} ‘’’ ```python # del 이용하기 - 키가 없는 경우 raise KeyError Lagom = { 'name' : '조OO', 'age' : 32, 'marital' : False, 'height' : 183, 'Friend' : { 'MinWook', 'Jinho' } } del Lagom['weight'] ''' KeyError Traceback (most recent call last) Cell In [14], line 11 1 Lagom = { 2 'name' : '조OO', 3 'age' : 32, (...) 9 } 10 } ---&gt; 11 del Lagom['weight'] KeyError: 'weight' ''' # pop 이용하기 - 키가 있는 경우 대응하는 value 리턴 Lagom = { 'name' : '조OO', 'age' : 32, 'marital' : False, 'height' : 183, 'Friend' : { 'MinWook', 'Jinho' } } Lagom.pop('age', 18) ''' 32 ''' # pop 이용하기 - 키가 없는 경우 대응하는 default 리턴 Lagom = { 'name' : '조OO', 'age' : 32, 'marital' : False, 'height' : 183, 'Friend' : { 'MinWook', 'Jinho' } } Lagom.pop('weight', 18) ''' 18 ''' 🔖 Iterate Dictionary를 for문을 이용하여 조회할 때 두가지 방법 key로 순회하기 key, value동시 순회하기(item() 사용) Lagom = { 'name' : '조OO', 'age' : 32, 'marital' : False, 'height' : 183, 'Friend' : { 'MinWook', 'Jinho' } } for key in Lagom: print(key) ''' name age marital height Friend ''' Lagom = { 'name' : '조OO', 'age' : 32, 'marital' : False, 'height' : 183, 'Friend' : { 'MinWook', 'Jinho' } } for key, value in Lagom.items(): print(key, value) ''' name 조OO age 32 marital False height 183 Friend {'Jinho', 'MinWook'} ''' 그 외 Dictionary 팁 특정 키 유무 확인 print('name' in {'name' : '조OO', 'age' : 32}) key 또는 value만 뽑아내는 방법 {'name' : '조OO', 'age' : 32}.keys() {'name' : '조OO', 'age' : 32}.values()",
    "tags": "data_structure study",
    "url": "/study/2023/02/24/%ED%95%B4%EC%8B%9C(Hash).html"
  },{
    "title": "[Algorithm] 선택 정렬 (Selection Sort)",
    "text": "선택 정렬 (Selection Sort) 정렬 알고리즘 중에서 가장 직관적이고 쉽게 구현이 가능한 선택 정렬(Selection Sort)에 대해 알아보려고 한다. 개념 선택 정렬은 거품 정렬과 많이 유사하다. 해당 순서에 원소를 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘이다. 거품정렬의 경우 앞에서 서로 인접한 두개의 요소를 비교하여 제일 큰 값부터 뒤로 보내는 알고리즘이었다면, 선택 정렬은 앞에서 부터 제일 작은 값을 순차적으로 나열하는 방식의 알고리즘이다. 이제 하나의 배열을 가지고 위에서 설명한 선택 정렬이 어떻게 진행되는지 알아보자. 주어진 배열 중에 최소값을 찾는다. 그 값을 맨 앞에 위치한 값과 교체한다. 맨 처음 위치를 뺀 나머지 배열을 같은 방법으로 교체한다. 다음과 같이 4명의 친구들의 키를 알고 있는데 순서대로 세우고 싶다. 170cm, 180cm, 150cm, 160cm 위와 같이 키를 알고 있는 4명의 친구들 중 키가 제일 작은 150cm인 친구를 맨 앞에 세운다. 150cm (4명 중 제일 작음) 키가 150cm인 친구는 맨 앞에 세웠으니, 이제 나머지 세 친구를 비교하여 키가 두 번째로 작은 160cm인 친구를 그 다음에 세운다. 150cm, 160cm (150cm 빼고 남은 3명 중 제일 작음) 이제 키가 70cm, 180cm인 친구만 남았다. 둘 중 170cm인 친구가 더 작기 때문에 그 다음에 세우고 180cm인 친구를 마지막에 세운다. 즉, 크기 n의 배열이 주어졌을 때, index 0부터 n-1까지의 모든 index i에 대해, i번째 부터 n-1번째까지 값 중 가장 작은 값을 구해서 index i에 놓으면 정렬된 배열을 얻을 수가 있다. 모든 index에 대해서 그 index에 위치시킬 값을 \"선택\"하기 때문에 이 정렬 알고리즘을 \"선택 정렬\" 또는 \"Selection Sort\"라고 부른다. GIF로 이해하는 Selection Sort 특징 선택 정렬은 정렬된 값을 배열의 맨 앞부터 하나씩 채워나가게 된다. 따라서, 뒤에 있는 index로 갈수록 비교 범위가 하나씩 점점 줄어드는 특성을 가지고 있다. 이 특성은 최대 값을 뒤에서 부터 채워나가는 버블 정렬과 동일한 특성을 가진다. 입력 배열이 이미 정렬되어 있건 말건 관계없이 동일한 연산량을 가지고 있기 때문에 최적화 여지가 적어서 시간복잡도가 O(N^2)으로 비효율적이다. 복잡도 선택 정렬은 별도의 추가 공간을 사용하지 않고 주어진 배열이 차지하고 있는 공간 내에서 값들의 위치만 바꾸기 때문에 O(1)의 공간 복잡도를 가진다. 시간 복잡도는 우선 루프문을 통해 모든 인덱스에 접근해야 하기 때문에 기본적으로 O(N)을 시간을 소모하며, 하나의 루프에서는 현재 인덱스의 값과 다른 인덱스의 값들과 비교하여 최소 값을 찾은 후 현재 인덱스에 있는 값과 서로 자리를 변경해야 하기 때문에 O(N)의 시간이 필요하게 된다. 최종적으로 선택 정렬은 O(N^2)의 시간 복잡도를 가지는 정렬 알고리즘이다. 데이터의 개수가 n개라고 했을 때, 첫 번째 회전에서의 비교횟수 : 1 ~ (n-1) =&gt; n-1 두 번째 회전에서의 비교횟수 : 2 ~ (n-1) =&gt; n-2 ... (n-1) + (n-2) + .... + 2 + 1 =&gt; n(n-1)/2 Python 코드 거품 정렬과 마찬가지로 두 개의 반복문이 필요하다. 내부 반목문에서는 현재 index부터 마지막 index까지 최소값의 index를 찾아내고, 외부 반복문에서는 이 최소값의 index와 현재 index에 있는 값을 변경한다. 외부 반복문에서는 index i를 0에서 n-2(또는 n-1. 마지막 index에서는 남는 갓이 하나 밖에 없기 때문에 대소에 지장 없음)까지 진행, 내부 반복문에서 이미 정렬된 값들에서는 관심이 없기 때문에 index j를 i에서 n-1까지 진행시킨다. 각 index에 대해서 최소값을 찾기 위해 대소 비교는 여러번 일어나나 상호 교대는 한번만 일어난다. def selection_sort(array): for i in range(len(array)-1): min_idx = i for j in range(i+1, len(array)): if array[j] &lt; array[min_idx]: min_idx = j array[i], array[min_idx] = array[min_idx], array[i] return array height = [190, 170, 150, 160, 180] print(selection_sort(height)) 결론 버블 정렬과 유사하지만 조금 더 빠른 선택 정렬에 대해 정리해 보았다. 시간 측정을 해 보았지만 정말 미묘하게 더 빠른 타임을 가진다. import timeit def time_decorator(func): def exec_func(*args, **kwargs): start_time = timeit.default_timer() result = func(*args, **kwargs) print(timeit.default_timer() - start_time) return result return exec_func @time_decorator def selection_sort(array): for i in range(len(array)-1): min_idx = i for j in range(i+1, len(array)): if array[j] &lt; array[min_idx]: min_idx = j array[i], array[min_idx] = array[min_idx], array[i] return array select_arry = [10, 1, 9, 2, 8, 3, 7, 4, 6, 5] print(selection_sort(select_arry)) # 6.4999330788850784e-06 # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]",
    "tags": "algorithm study",
    "url": "/study/2023/02/02/%EC%84%A0%ED%83%9D-%EC%A0%95%EB%A0%AC(Selection-Sort).html"
  },{
    "title": "[Computer Science] 중앙처리장치(CPU) 작동 원리?",
    "text": "중앙처리장치(CPU)란? 중앙처리장치(CPU)는 명령어의 해석과 자료의 연산, 비교등의 처리를 제어하는 컴퓨터 시스템의 핵심장치이다. 다양한 입력 장치로부터 정보를 입력받아 처리한 후, 그 결과를 출력장치로 보내는 일련의 과정을 제어하고 조정하는 일을 수행한다. CUP는 사람의 두뇌와 같이 컴퓨터의 모든 시스템을 제어, 처리하는 가장 핵심적인 장치라고 할 수 있다. CPU 구성요소 출처: https://mk28.tistory.com/15 CPU는 크게 제어장치, 연산장치(ALU), 레지스터와 각 구성 요소를 연결하는 내부 버스로 구성되어 있다. 🔖 연산 장치 명령어를 실행하기 위한 마이크로연산(산술연산과 논리연산)을 수행 연산에 필요한 데이터를 레지스터에서 가져오고 산술, 논리, 관계, 이동 등 다양한 연산을 수행 연산 결과를 다시 레지스터로 보냄 🔖 제어 장치 명령어를 순서대로 실행할 수 있도록 제어하는 장치 주기억장치에서 프로그램 명령어를 꺼내 해독하고, 그 결과에 따라 명령어 실행에 필요한 제어 신호를 기억장치, 연산장치, 입출력장치로 보냄 또한 이들 장치가 보낸 신호를 받아 다음에 수행할 동작을 결정 🔖 레지스터 CPU(중앙 처리 장치)내에 있는 소규모의 고속 기억장치 명령어 주소, 코드, 연산에 필요한 데이터 련산 결과 등을 임시로 저장 용도에 따라 범용 레지스터와 특수 목적 레지스터로 구분 레지스터는 메모리 계층의 최상위에 위치하며 가장 빠른 속도로 접근 가능한 메모리이다. 중앙처리장치 종류에 따라 사용할 수 있는 레지스터 개수와 크기가 다름 범용 레지스터 : 연산에 필요한 데이터나 연산 결과를 임시로 저장 특수목적 레지스터 : 특별한 용도로 사용하는 레지스터 🔖 특수 목적 레지스터의 종류 MAR (메모리 주소 레지스터) : 읽기와 쓰기 연산을 수행할 주기억장치 주소를 저장 PC (프로그램 카운터) : 다음에 실행될 명령어의 주소를 저장 SP (스택 포인터) : 스택의 최상위 주소를 저장 IX (인덱스 레지스터) : 인덱스 주소 지정 방식에서 인덱스를 저장 IR (명령어 레지스터) : 명령어를 호출해서 해독하기 위해 현재 명령어를 임시로 저장 MBR (메모리 버퍼 레지스터) : 주기억장치의 내용을 임시로 저장하는 역할 AC (누산기) : 산술 논리 장치의 연산 결과를 임시로 저장 PSR (프로그램 상태 레지스터) : CPU의 현재 상태 정보를 저장 CPU 연산&amp;동작 과정 🔖 연산 CPU의 연산 순서는 Fetch-&gt;Decode-&gt;Execute-&gt;Writeback으로 이루어지며 각 과정의 설명은 다음과 같다. Fetch(인출): 메모리상의 프로그램 카운터(PC)가 가리키는 명령어를 CPU가 가르키는 명령어를 CPU로 인출하여 적재 Decode(해석): 명령어의 해석. 이 단계에서 명령어의 종류와 타겟 등을 판단한다. Execute(실행): 해석된 명령어에 따라 데이터에 대한 연산을 수행한다. Writeback(쓰기): 명령어대로 처리 완료된 데이터를 메모리에 기록한다. 🔖 동작 과정 (1) 보조기억장치에서 저장된 프로그램을 읽거나, 입력장치에서 입력받은 데이터를 주기억장치에서 읽는다. (2) 주기억장치에서 읽어온 데이터를 중앙처리장치(CPU)가 읽고 처리한 후 다시 주기억장치로 보낸 후 저장한다. (3) 주기억장치는 연산된 데이터를 출력장치에 보내거나 보조기억장치에 저장한다. (4) 제어장치는 (1)-(3)과정에서 명령어가 순서대로 잘 실행되도록 제어하는 역할을 수행. CPU의 명령어 🔖 명령어 세트 명령어 세트는 CPU가 실행할 명령어의 집합이다. 명령어 세트는 실행할 연산을 나타내는 연산 코드(Operation Code)와 연산에 필요한 데이터나 데이터의 저장 위치를 나타내는 피연산자(Operand)로 구성된다. 🔖 연산 코드 (Operation Code) 연산 코드는 실행하는 연산의 종류에 따라 다음과 같이 네 가지 기능으로 나뉜다. 연산 기능 : 사칙연산, 이동(shift), 보수 등의 산술연산과 논리곱, 논리합, 부정 등의 논리연산을 수행한다. 제어 기능 : 조건 분기와 무조건 분기 등을 사용하여 명령어의 실행 순서를 제어한다. 데이터 전달 기능 : 레지스터와 레지스터 사이, 레지스터와 주기억장치 사이에서 데이터를 전달한다. 입출력 기능 : 프로그램과 데이터를 주기억장치에 전달하고, 연산 결과는 출력장치에 전달한다. 🔖 피연산자 (Operand) 피연산자에는 주소, 숫자/문자, 논리 데이터 등을 저장할 수 있다. 주소 : 기억장치 혹은 레지스터의 주소가 저장된다. 숫자/문자 : 숫자는 정수, 고정 소수점 수, 부동 소수점 수 및 각각의 코드로 저장되고 문자는 아스키코드로 저장된다. 논리 데이터 : 참 또는 거짓을 표현할 때 사용하며 비트나 플래그로 저장된다. 명령어 사이클 CPU에서는 프로그램을 실행하기 위해 주기억장치에서 명령어를 순차적으로 인출하여 해독하고 실행하는 과정을 반복하는데, CPU가 주기억장치에서 한 번에 하나의 명령어를 인출하여 실행하는데 필요한 일련의 활동을 명령어 사이클 (Instruction Cycle)이라고 한다. 명령어 사이클은 인출 사이클, 실행 사이클, 간접 사이클, 인터럽트 사이클로 세분화 시킬 수 있는데, 인출 사이클과 실행 사이클은 항상 수행되지만 / 간접 사이클과 인터럽트 사이클은 주소 지정방식이 필요할 때나 인터럽트 요구가 있을 때만 수행된다. 🔖 인출사이클과 특수 목적 레지스터의 동작 과정 프로그램 카운터(PC)에 저장된 주소를 메모리 주소 레지스터(MAR)로 전달 한다. 메모리 주소 레지스터(MAR)에 저장된 내용을 토대로 주기억장치의 해당 주소에서 명령어를 인출한다. 인출한 명령어를 메모리 버퍼 레지스터(MBR)에 저장한다. 다음 명령어를 인출하기 위해 프로그램 카운터 (PC)의 값을 증가 시킨다. 메모리 버퍼 레지스터(MBR)에 저장된 내용을 명령어 레지스터(IR)에 전달한다. 위 과정을 다음과 같이 표현하기도 한다. T0 : MAR &lt;- PC T1 : MBR &lt;- M[MAR], PC &lt;- PC + 1 T2 : IR &lt;- MBR 🔖 실행 사이클과 특수 목적 레지스터의 동작 과정 다음은 인출 사이클로부터 명령어를 인출한 이후 명령어를 실행하는 과정인 실행 사이클의 과정이다. 그 중에서도 더하기(ADD) 연산으로 과정을 살펴보자. 명령어 레지스터(IR)의 내용을 메모리 주소 레지스터(MAR)로 전달한다. 메모리에 저장된 데이터 값을 메모리 버퍼 레지스터(MBR)에 저장한다. 누산기(AC)에 저장된 값에 ADD연산을 실행한다. 실행 사이클도 인출 사이클과 마찬가지로 다음과 같이 표현 할 수 있다. ADD addr 명령어 연산 T0 : MAR &lt;- IR(Addr) T1 : MBR &lt;- M[MAR] T2 : AC &lt;- AC + MBR 실행 사이클에서는 프로그램 카운터를 증가시키지 않는 이유 인출 사이클과 다르게 실행 사이클에서는 프로그램 카운터(PC)를 증가시키지 않는데, 이미 인출이 진행 되고 명령어 실행만 하면 되는 상황이기 때문에 프로그램 카운터를 증가시킬 필요가 없다. 즉, 이미 인출이 되어 명령어 레지스터(IR)에 메모리 버퍼 레지스터(MBR)의 값이 저장된 상태라는 의미이다.",
    "tags": "computer_science study",
    "url": "/study/2023/01/31/%EC%A4%91%EC%95%99%EC%B2%98%EB%A6%AC%EC%9E%A5%EC%B9%98(CPU)-%EC%9E%91%EB%8F%99-%EC%9B%90%EB%A6%AC.html"
  },{
    "title": "[Computer Science] 컴퓨터란?",
    "text": "컴퓨터란? compute라는 어원을 가지며, 계산하는 기계라는 의미를 가지고 있다. 여기서 계산이라는 것은 우리가 생각하는 산수가 아닌 좀더 포괄적인 개념이다. 그렇다면 계산하는 기계인 컴퓨터가 가지는 구성에 대해 알아보자. 컴퓨터 시스템은 크게 하드웨어와 소프트웨어로 나누어진다. 하드웨어: 컴퓨터를 구성하는 기계적 장치 소프트웨어: 하드웨어의 동작을 지시하고 제어하는 명령어 집합 하드웨어 하드웨어는 마우스, 키보드 등 실제로 존재하는 컴퓨터를 구성하는 장치를 말한다. 창고: http://jangun.com/study/ComputerScienceIntroduction.html 중앙처리장치(CPU) 기억장치: RAM, HDD 입출력장치: 마우스, 프린터, 모니터 등 실재하는 컴퓨터는 하드웨어는 중앙처리장치(CPU), 기억장치, 입출력장치 로 구성되어 있다. 이들은 시스템 버스로 연결이 되어 있으며, 시스템 버스는 데이터와 명령 제어 신호를 각 장치로 실어나르는 역할을 한다. 🔖 CPU이란? 컴퓨터에서 `계산`을 담당하는 두뇌라고 생각하면 된다. 주기억장치에서 프로그램 명령어와 데이터를 읽어와 처리하고 명령어의 수행 순서를 제어한다. 중앙처리장치(CPU)는 비교와 연산을 담당하는 `산술논리연산장치(ALU)`와 명령어의 해석과 실행을 담당하는 `제어장치`, 속도가 빠른 데이터 기억장소인 `레지스터`로 구성되어 있다. 계산을 담당하는 만큼 처리속도가 그만큼 빠르다. 🔖 RAM이란? 우리가 수학문제를노트하고 연필을 이용하여 풀듯, CPU가 하는 계산을 노트와연필을 이용하여 도와주는 역할을 RAM이라고 생각하면 된다. 내 두뇌만을 이용해서 문제를 풀 수 있지만 노트와 연필을 이용한 보조장치를 이용하면 더 손쉬운 문제풀이가 가능하기 때문에 RAM이라는 하드웨어가 존재하는 것이다. 🔖 보조장치란? 좁은 의미의 컴퓨터는 CPU, RMA을 합친거라고 생각하면 나머지는 보조장치라고 할 수 있다.(입출력장치, 보조 기억장치) 🔖 보조 기억 장치(HDD, SDD)란? RAM도 사실상 용량이 그렇게 크지 않기 때문에 보조 기억 장치를 이용한다. 우리가 자주 접하는 컴퓨터 용량이나 외장 하드, SSD가 이에 포함된다. 🔖 시스템 버스 하드웨어 구성 요소를 물리적으로 연결하는 선을 의미 각 구성요소가 다른 구성요소로 데이터를 보낼 수 있도록 통로가 되어준다. 용도에 따라 `데이터 버스`, `주소 버스`, `제어 버스`로 나누어 진다. 데이터 버스 : 중앙처리장치와 기타 장치 사이에서 데이터를 전달하는 통로 기억장치와 입출력장치의 명령어와 데이터를 중앙처리장치로 보내거나 중앙처리장치의 연산 결과를 기억장치와 입출력장치로 보내는 양방향버스 주소 버스 : 데이터를 정확히 실어나르기 위해서는 기억 장치 주소를 정해주어야 함. 주소 버스는 중앙처리장치가 주기억 장치나 입출력장치로 기억장치 주소를 전달하는 통로이기 때문에 단방향버스임 제어 버스 : 주소 버스와 데이터 버스는 모든 장치에 공유되기 때문에 이를 제어할 수단이 필요 제어 버스는 중앙처리 장치가 기억장치나 입출력장치에 제어 신호를 전달하는 통로임 제어 신호 종류 : 기억장치 읽기 및 쓰기, 버스 요청 및 승인, 인터럽트 요청 및 승인, 클락, 리셋 등 제어 버스는 읽기 동작과 쓰기 동작을 모두 수행하기 때문에 양방향버스임 소프트웨어 소프트웨어는 눈으로는 볼 수 있지만 손으로는 만질 수 없는 것들을 의민한다. 시스템 소프트웨어: 운영체제, 컴파일러 응용 소프트웨어: 워드프로세서, 스프레드시트",
    "tags": "computer_science study",
    "url": "/study/2023/01/25/%EC%BB%B4%ED%93%A8%ED%84%B0%EB%9E%80.html"
  },{
    "title": "[Algorithm] 거품 정렬 (Bubble Sort)",
    "text": "거품 정렬 (Bubble Sort) 개념 거품 정렬은 뒤에서 부터 앞으로 정렬을 해나가는 구조를 가지고 있다. (오름차순)즉, 배열 내의 인접한 값들을 앞뒤로 비교하며 자리를 바꾸는데 맨 뒷자리로 제일 큰 값을 보내는 작업을 수행한다. 이렇게 하나씩 큰 값을 뒤쪽으로 보내 채워 나가며 앞으로 정렬해 왔을 때 작은 수 부터 큰 수 까지 오름차순으로 정렬된 배열을 가지는 정렬이다. 큰 값을 계속해서 뒤로 보내는 모습이 마치 방울이 이동하는 것과 같이 보여서 거품 정렬이라는 이름이 붙어졌다. 이제 하나의 배열을 가지고 위에서 설명한 거품정렬이 어떻게 진행되는지 알아보자. 다음과 같이 1부터 5까지 총 5개의 숫자가 들어있는 배열이 존재한다. [3, 2, 4, 5, 1] 먼저 3, 2를 비교, 3이 2보다 크기 때문에 자리를 바꾸며 큰 값을 뒤로 보내준다. [3, 2, 4, 5, 1] 3 &gt; 2 =&gt; switch [2, 3, 4, 5, 1] 그 다음 3, 4를 비교, 3은 4보다 크지 않기 때문에 그대로 유지한다. [2, 3, 4, 5, 1] 3, 4 =&gt; keep 그 다음 4, 5를 비교, 4는 5보다 크지 않기 때문에 그대로 유지한다. [2, 3, 4, 5, 1] 4, 5 =&gt; keep 그 다음 5, 1를 비교, 5는 1보다 크기 때문에 자리를 바꾸며 큰 값을 뒤로 보내준다. [2, 3, 4, 5, 1] 5 &gt; 1 =&gt; switch [2, 3, 4, 1, 5] 이렇게 값을 처음부터 비교해가며 앞의 값이 뒤의 값보다 큰 경우 자리를 바꿔주면 제일 큰 값을 맨 뒤로 보내줄 수 있다. 위의 과정은 제일 큰 값을 맨 뒤로 보내주는 작업이며 그다음은 두번째 큰 값을 제일 큰 값 앞으로 보내주는 과정을 진행해 주면 된다. origin: [3, 2, 4, 5, 1] ----------------------- loop 1: [2, 3, 4, 1, 5] * loop 2: [2, 3, 1, 4, 5] * * loop 3: [2, 1, 3, 4, 5] * * * loop 4: [1, 2, 3, 4, 5] * * * * loop 5: [1, 2, 3, 4, 5] * * * * * GIF로 이해하는 Bubble Sort 특징 거품 정렬은 점점 큰 값들이 뒤에서 앞으로 쌓여 이동하기 때문에 정렬의 범위가 하나씩 줄어든다. 다음 loop에서 제일 뒤로 간 큰 값은 비교를 할 필요가 없기 때문이다. 제일 작은 값을 맨 앞으로 이동시키는 선택 정렬과 정렬 방향이 반대이다. 선택정렬에 비해 자리 변경이 더 많이 일어난다. 위의 loop 4, loop 5를 보면 필요없는 과정이 있어 최적화가 필요하다. 복잡도 거품 정렬은 별도의 추가 공간을 사용하지 않고 배열안에서 값들의 위치가 변경되기 때문에 0(1)의 공간 복잡도를 가진다. 시간 복잡도는 반복문을 통해 맨 뒤에서 맨 앞까지 모든 인덱스에 접근하기 때문에 기본적으로 0(N) 시간을 소모하며, 하나의 루프에서는 인접한 값들의 대소 비교 및 자리 교대를 위해서 0(N) 시간을 필요하게 된다. 따라서 거품 정렬은 총 0(N^2)의 시간 복잡도를 가진다. 정렬이 이미 완료된 배열인 경우에는 0(N) 시간 복잡도를 가진다. Python 코드 선택 정렬과 마찬가지로 두 개의 반복문이 필요하다. 내부 반복문에서는 첫번째 값부터 이전 패스에서 뒤로 보내놓은 값이 있는 위치 전까지 앞뒤 값을 계속해서 비교해나가면서 앞의 값이 뒤의 값보다 클 경우 자리 변경(switch)을 한다. 외부 반복문에서는 뒤에서 부터 앞으로 정렬 범위를 n-1부터 1 까지 줄여나간다. def bubbleSort(array): length = len(array)-1 for i in range(length): for j in range(length-i): if array[j] &gt; array[j+1]: array[j],array[j+1] = array[j+1], array[j] return array bubble_arry = [10, 1, 9, 2, 8, 3, 7, 4, 6, 5] print(bubbleSort(bubble_arry)) 최적화 이전 loop에서 앞뒤 자리 변경(switch)이 한 번도 일어나지 않았다면 정렬도지 않는 값이 하나도 없었다고 할 수 있다. 따라서 이러한 경우 loop를 수행하지 않아도 된다. origin: [1, 2, 3, 5, 4] ------------------------ loop 1: [1, 2, 3, 4, 5] =&gt; switch 있음 * loop 2: [1, 2, 3, 4, 5] =&gt; switch 없음 * * =&gt; 이전 패스에서 loop이 한 번도 없었으니 종료 import timeit def time_decorator(func): def exec_func(*args, **kwargs): start_time = timeit.default_timer() result = func(*args, **kwargs) print(timeit.default_timer() - start_time) return result return exec_func @time_decorator def bubbleSort(array): length = len(array)-1 for i in range(length): switch = False for j in range(length-i): if array[j] &gt; array[j+1]: array[j], array[j+1] = array[j+1], array[j] switch = True if not switch: break return array bubble_arry = [10, 1, 9, 2, 8, 3, 7, 4, 6, 5] print(bubbleSort(bubble_arry)) 최적화 최적화 하여 코드를 변경하고 시간을 측정해 봤을때 실행 속도가 많이 빨라졌다는 느낌은 없었다. 하지만 최적화 전보다 빈번하게 더 시간이 단축되어 실행되는 경우가 발생한 것을 보니 코드 최적화가 조금은 된 것으로 보인다.",
    "tags": "algorithm study",
    "url": "/study/2023/01/25/%EA%B1%B0%ED%92%88-%EC%A0%95%EB%A0%AC(Bubble-Sort).html"
  }]};
